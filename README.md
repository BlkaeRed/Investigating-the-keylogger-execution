# Investigating the keylogger execution

This is a continuation of my keylogger creation. I wanted to perform some very simple network analysis of the traffic generated by my keylogger using Wireshark and Tshark. It also served as another way of testing its functionality — in other words, checking how many keystrokes are sent and lost, how detectable it is, and whether it works at all. I wanted to make sure I hadn’t missed anything during initial testing.

## Testing procedure
All tests were done by creating an EC2 instance on which I started an HTTPS server. The keylogger was run on my personal Windows machine, mostly because I know what I created, so there was no concern about executing actual malicious software.

The test procedure involved me visiting random websites to generate traffic and typing random sentences (some disguised as important data, such as passwords) while the keylogger was active. During all of this, Wireshark recorded all network traffic, which was later used for further analysis. This approach was intended to ensure the test was “realistic” and the traffic was similar to what might be seen during normal usage. The resulting traffic was saved as a `.pcapng` file and analyzed further using Tshark.

Two things to mention before going to specific investigations. In this exercise, I decided to focus on network traffic as an indicator of potential malware presence. However, that is not the only way to detect malware. Spikes in resource usage, unusually slow performance, and suspicious process execution are also important indicators for determining whether malware infection has occurred. In this case, because I was the one running the “malware” and because it is extremely lightweight (and therefore doesn’t use many system resources), I decided to omit those aspects.
Second, during testing, I made some small changes to the code, mostly to make it more elusive and reliable. The first iteration, with a wait time of 10 seconds between packets, often resulted in lost keystrokes. That’s why, for this exercise, the starting point was 30 seconds. The second part of testing included code with a random wait time.

## PowerShell

First, I tested whether it was possible to detect the keylogger using PowerShell. Given the nature of my keylogger, I didn’t have high hopes. The malware doesn’t maintain a persistent connection but instead starts new connections each time, so cmdlets like `Get-NetTcpConnection` would not work well — and that’s exactly what I found.

<img width="1424" height="37" alt="Zrzut ekranu 2025-08-12 154336" src="https://github.com/user-attachments/assets/54167492-6541-4373-83e7-f6f97aae3833" />
I had to try several times to get this result, and it disappeared the next second. This is not a reliable way of detecting this specific malware, but I wrote a script that consistently waits and checks for connections to a specific address. It outputs the local and remote address/port, connection state, responsible process, and the process’s command line. I’m not sure how effective this would be in a real-world scenario, because it would require a lot of filtering and tweaking for a specific organization. However, for anyone interested, the script can be found in this repository. Here’s an example output:

<img width="1687" height="188" alt="obraz" src="https://github.com/user-attachments/assets/34d0c263-f14d-420f-bb8e-7d92f6057362" />


## Wireshark

### With constant wait time 30 seconds

Next, I tested the keylogger using Wireshark. I visited random websites such as x.com, VirusTotal, and wp.pl, and typed random, important-sounding words and sentences — for example,
`email@personal.com password_unique123456` or
`important data, don’t let anyone but admin have access to it.`
I also made orthographic errors (many unintentionally) to see if this would make the collected keystrokes significantly harder to read. I continued until I reached around 30,000 packets.

Resulting page content:
<img width="1844" height="481" alt="Zrzut ekranu 2025-08-12 114517" src="https://github.com/user-attachments/assets/eab4c68b-eca0-4c05-8e3b-ebed3a38b1df" />  

Results in wireshark:  

<img width="353" height="135" alt="Zrzut ekranu 2025-08-12 114929" src="https://github.com/user-attachments/assets/da6f679c-a6ea-408e-8f02-f6ed499e476f" />

To analyze the traffic, I first examined every HTTP request and every HTTPS/TLS Client Hello message, which indicates the start of communication:
<img width="259" height="67" alt="Zrzut ekranu 2025-08-12 115419" src="https://github.com/user-attachments/assets/dbc406c3-e835-4e20-a45d-7e2554e191ae" />  

Here's what I found:  

<img width="1860" height="456" alt="Zrzut ekranu 2025-08-12 115137" src="https://github.com/user-attachments/assets/e270c8c9-f326-4940-9a9e-f3ce592d89cb" />  
Most packets looked normal. I then added “Domain” as a column to check for suspicious entries:  
<img width="1388" height="37" alt="Zrzut ekranu 2025-08-12 115551" src="https://github.com/user-attachments/assets/d4777387-6d0e-45bc-99b6-b6ba6be7d2d9" />  
And there it is. The lack of a domain is extremely suspicious — especially in the context of SSL traffic. No domain but HTTPS usage often means self-signed certificates, which are definitely not for public browsing. Another suspicious aspect is the regular timing between packets.

<img width="1450" height="30" alt="Zrzut ekranu 2025-08-12 115638" src="https://github.com/user-attachments/assets/c574184b-1bbb-4652-a865-d9aa7448c475" />  
<img width="1396" height="29" alt="Zrzut ekranu 2025-08-12 115619" src="https://github.com/user-attachments/assets/df370d9f-d6dd-4dd4-9848-209d0e052927" />  
<img width="1388" height="37" alt="Zrzut ekranu 2025-08-12 115551" src="https://github.com/user-attachments/assets/3ceab4ac-adb9-4a42-9560-9df69014c0e0" />   
As suspected, every packet is sent exactly 30 seconds after the last one. This is extremely suspicious and, in a real-world scenario, combined with the lack of a domain, would almost certainly indicate C2 communication over HTTPS.

### With random wait time between 30 and 60 seconds

Next, to slightly increase the challenge, I added a random wait time to my script. The investigation method remained essentially the same, but similar timing between packets was now harder to notice. To make it even harder, I could increase the range further, which might even bypass some security mechanisms such as IPS/IDS, depending on the security rules in place.  
<img width="798" height="314" alt="Zrzut ekranu 2025-08-12 122455" src="https://github.com/user-attachments/assets/c087a001-f813-40dc-afe5-e015f0795619" />  

I generated traffic in a similar way as before by visiting websites such as x.com, Reddit, YouTube, and typing private-looking phrases like:
`again really important files and data`
`how to hack pentagon" and "my credit card number is .........`  

<img width="1788" height="532" alt="Zrzut ekranu 2025-08-12 121553" src="https://github.com/user-attachments/assets/ce589a64-54ed-4633-993a-e3e41c879196" />

From the start, I focused on domainless connections using this Wireshark query:  
<img width="631" height="52" alt="Zrzut ekranu 2025-08-12 122131" src="https://github.com/user-attachments/assets/fd73b45d-257b-48a9-8802-fa228bc227c9" />  

And found this:
<img width="1425" height="390" alt="Zrzut ekranu 2025-08-12 122119" src="https://github.com/user-attachments/assets/2238702b-f037-43ff-8645-fc980c09a369" />  
There were many SSDP packets, which is normal and expected, but packets related to the keylogger were still visible. To view them more clearly, I changed the query to specify the found IP address as the destination:  
<img width="1339" height="167" alt="Zrzut ekranu 2025-08-12 122220" src="https://github.com/user-attachments/assets/7f5981e6-cfb6-4aa5-b2f0-ebb5bab99ff4" />  
The screenshot shows that packets are sent at random intervals, making them harder to detect if the traffic volume were larger. With a different (larger) wait-time range, it would be even more difficult — although this would noticeably reduce the keylogger’s efficiency and increase the likelihood of data loss if the user shuts down their PC.


## Tshark

Finally, I used Tshark. I wanted to use this tool mostly for IP + domain analysis, similar to what I did with Wireshark, but faster. This would be a significantly better option when traffic is very large and the keylogger actually uses a domain. My plan was to extract every combination of IP address and corresponding domain from the `.pcapng` and examine the results.

<img width="1656" height="754" alt="Zrzut ekranu 2025-08-12 124118" src="https://github.com/user-attachments/assets/5c30666e-77f3-4836-9909-6637785f859f" />  
This way, the suspicious IP address stands out immediately, making the investigation much easier and faster.







